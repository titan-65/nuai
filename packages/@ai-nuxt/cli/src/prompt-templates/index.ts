import fs from 'fs-extra'
import path from 'path'
import { getPromptTemplate } from '../templates'

/**
 * Prompt template interface
 */
export interface PromptTemplate {
  name: string
  type: string
  description: string
  content: string
  filePath?: string
}

/**
 * Prompt creation options
 */
export interface CreatePromptOptions {
  name: string
  type: string
  description: string
  content: string
}

/**
 * Get prompts directory
 */
function getPromptsDir(): string {
  return path.join(process.cwd(), 'prompts')
}

/**
 * Ensure prompts directory exists
 */
async function ensurePromptsDir(): Promise<void> {
  const promptsDir = getPromptsDir()
  await fs.ensureDir(promptsDir)
}

/**
 * Create a new prompt template
 */
export async function createPrompt(options: CreatePromptOptions): Promise<void> {
  await ensurePromptsDir()
  
  const promptsDir = getPromptsDir()
  const promptPath = path.join(promptsDir, `${options.name}.ts`)
  
  // Check if prompt already exists
  if (await fs.pathExists(promptPath)) {
    throw new Error(`Prompt template ${options.name} already exists`)
  }
  
  // Generate prompt template code
  const promptCode = generatePromptCode(options)
  
  // Write prompt file
  await fs.writeFile(promptPath, promptCode)
  
  // Update prompts index file
  await updatePromptsIndex()
}

/**
 * List all prompt templates
 */
export async function listPrompts(): Promise<PromptTemplate[]> {
  const promptsDir = getPromptsDir()
  
  if (!(await fs.pathExists(promptsDir))) {
    return []
  }
  
  const files = await fs.readdir(promptsDir)
  const promptFiles = files.filter(file => file.endsWith('.ts') && file !== 'index.ts')
  
  const prompts: PromptTemplate[] = []
  
  for (const file of promptFiles) {
    const filePath = path.join(promptsDir, file)
    const content = await fs.readFile(filePath, 'utf-8')
    
    // Parse prompt metadata from file content
    const prompt = parsePromptMetadata(content, file)
    if (prompt) {
      prompt.filePath = filePath
      prompts.push(prompt)
    }
  }
  
  return prompts
}

/**
 * Run a prompt template
 */
export async function runPrompt(name: string, input: string): Promise<string> {
  const prompts = await listPrompts()
  const prompt = prompts.find(p => p.name === name)
  
  if (!prompt) {
    throw new Error(`Prompt template ${name} not found`)
  }
  
  // In a real implementation, this would use the AI provider to execute the prompt
  // For now, return a mock response
  return `Prompt ${name} executed with input: ${input}\\n\\nTemplate content: ${prompt.content}`
}

/**
 * Delete a prompt template
 */
export async function deletePrompt(name: string): Promise<void> {
  const promptsDir = getPromptsDir()
  const promptPath = path.join(promptsDir, `${name}.ts`)
  
  if (!(await fs.pathExists(promptPath))) {
    throw new Error(`Prompt template ${name} not found`)
  }
  
  await fs.remove(promptPath)
  await updatePromptsIndex()
}

/**
 * Generate prompt template code
 */
function generatePromptCode(options: CreatePromptOptions): string {
  const baseTemplate = getPromptTemplate(options.type as any, options.name)
  
  // Replace placeholder content with actual content
  return baseTemplate.replace(
    /baseInstructions: `[^`]+`/,
    `baseInstructions: \`${options.content}\``
  ).replace(
    /systemPrompt: `[^`]+`/,
    `systemPrompt: \`${options.content}\``
  )
}

/**
 * Update prompts index file
 */
async function updatePromptsIndex(): Promise<void> {
  const promptsDir = getPromptsDir()
  const indexPath = path.join(promptsDir, 'index.ts')
  
  const prompts = await listPrompts()
  
  let indexContent = '/**\n * Prompt templates index file\n * Auto-generated by AI Nuxt CLI\n */\n\n'
  
  // Add imports
  prompts.forEach(prompt => {
    indexContent += `export { ${prompt.name} } from './${prompt.name}'\n`
  })
  
  // Add prompts registry
  indexContent += '\n/**\n * Available prompt templates\n */\n'
  indexContent += 'export const prompts = {\n'
  prompts.forEach(prompt => {
    indexContent += `  ${prompt.name},\n`
  })
  indexContent += '}\n'
  
  // Add prompt metadata
  indexContent += '\n/**\n * Prompt template metadata\n */\n'
  indexContent += 'export const promptMetadata = [\n'
  prompts.forEach(prompt => {
    indexContent += `  {\n`
    indexContent += `    name: '${prompt.name}',\n`
    indexContent += `    type: '${prompt.type}',\n`
    indexContent += `    description: '${prompt.description}'\n`
    indexContent += `  },\n`
  })
  indexContent += ']\n'
  
  // Add utility functions
  indexContent += '\n/**\n * Utility functions\n */\n'
  indexContent += 'export function getPrompt(name: string) {\n'
  indexContent += '  return prompts[name as keyof typeof prompts]\n'
  indexContent += '}\n\n'
  indexContent += 'export function getPromptMetadata(name: string) {\n'
  indexContent += '  return promptMetadata.find(p => p.name === name)\n'
  indexContent += '}\n'
  
  await fs.writeFile(indexPath, indexContent)
}

/**
 * Parse prompt metadata from file content
 */
function parsePromptMetadata(content: string, filename: string): PromptTemplate | null {
  try {
    // Extract prompt name from export
    const nameMatch = content.match(/export const (\w+) = {/)
    const name = nameMatch ? nameMatch[1] : path.basename(filename, '.ts')
    
    // Extract description
    const descMatch = content.match(/description: ['"`]([^'"`]+)['"`]/)
    const description = descMatch ? descMatch[1] : 'No description'
    
    // Extract type
    const typeMatch = content.match(/type: ['"`]([^'"`]+)['"`]/)
    const type = typeMatch ? typeMatch[1] : 'unknown'
    
    // Extract content (from systemPrompt or baseInstructions)
    const systemPromptMatch = content.match(/systemPrompt: `([^`]+)`/)
    const baseInstructionsMatch = content.match(/baseInstructions: `([^`]+)`/)
    const content_text = systemPromptMatch ? systemPromptMatch[1] : 
                        baseInstructionsMatch ? baseInstructionsMatch[1] : 
                        'No content'
    
    return {
      name,
      type,
      description,
      content: content_text
    }
  } catch (error) {
    console.error(`Error parsing prompt metadata from ${filename}:`, error)
    return null
  }
}